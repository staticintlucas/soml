#!/usr/bin/env python3

import tests.de_only
import tests.reference
import tests.ser_de
from utils import *

import argparse
import re
import sys
from textwrap import dedent, indent

HEADER = dedent(f"""\
    # Comparison of TOML crates

    These tables are autogenerated by [`{paths.script()}`][{paths.script()}]:
""")
HEADER_URLS = {
    paths.script(): paths.repo_url(paths.script())
}

FOOTNOTE = dedent("""\
    Increase in `.text` section size compared to a baseline which just reads/writes the TOML as plain text.
    This is calculated using [`cargo-bloat`][cargo-bloat] with the release profile.
""")
FOOTNOTE_URLS = {
    "cargo-bloat": "https://crates.io/crates/cargo-bloat",
}

START_TAG = "<!-- binsize start -->"
END_TAG = "<!-- binsize end -->"

def result_to_table(title: str, results: list[tuple[crates.Crate, crates.Results]], baseline: int) -> str:
    table = markdown.Table(
        title,
        headers=["Crate", "Version", "Size {1}", "Maintained", "TOML version"],
        footnotes=[FOOTNOTE],
    )
    for crate, result in results:
        package = f"[{crate.package}]"
        if crate.notes is not None:
            package = f"{package}<br>({crate.notes})"
        size = f"{(result.size - baseline) / 1024:.0f} KiB"
        maintained = "✅" if crate.maintained else "❌"
        table.add_row(
            [package, result.version, size, maintained, crate.toml_ver],
            footnotes=crate.footnotes,
        )
    return str(table)

def generate_output() -> str:
    crates_toml = paths.script_root() / "crates.toml"
    test_crates = crates.load(crates_toml)

    output = [HEADER.rstrip()]

    result = tests.reference.run_test()
    baseline = result.size

    de_only_results = []
    for crate in test_crates:
        result = tests.de_only.run_test(crate)
        de_only_results.append((crate, result))
    output.append(result_to_table("Deserialize-only", de_only_results, baseline))

    ser_de_results = []
    for crate in test_crates:
        result = tests.ser_de.run_test(crate)
        ser_de_results.append((crate, result))
    output.append(result_to_table("Deserialize and Serialize", ser_de_results, baseline))

    urls = {**HEADER_URLS, **FOOTNOTE_URLS}
    urls.update({crate.package: crate.url for crate in test_crates})
    output.append(markdown.format_urls(urls))

    return "\n\n".join(output)

def generate_doc_comment() -> str:
    output = generate_output()

    return "\n".join((
        START_TAG,
        "//!",
        indent(indent(output, " "), "//!", lambda _: True),
        "//!",
        f"//! {END_TAG}",
    ))

def write_doc_comment(comment: str) -> None:
    lib_rs = paths.soml_root() / "src" / "lib.rs"
    text = lib_rs.read_text()
    text = re.sub(rf"{START_TAG}.*?{END_TAG}", comment, text, flags=re.MULTILINE | re.DOTALL)
    lib_rs.write_text(text)

def check_doc_comment(comment: str) -> bool:
    lib_rs = paths.soml_root() / "src" / "lib.rs"
    text = lib_rs.read_text()
    text = re.search(rf"{START_TAG}.*?{END_TAG}", text, flags=re.MULTILINE | re.DOTALL).group()
    return text == comment

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate binary size stats of soml compared to other TOML crates",
    )
    parser.add_argument("--check", action="store_const", const="check", dest="cmd")
    parser.add_argument("--update", action="store_const", const="update", dest="cmd")
    args = parser.parse_args()

    if args.cmd == "check":
        matches = check_doc_comment(generate_doc_comment())
        if not matches:
            print("error: doc comment is not up to date", file=sys.stderr)
            return 3
    elif args.cmd == "update":
        write_doc_comment(generate_doc_comment())
    else:
        print(generate_output())
    return 0

if __name__ == "__main__":
    sys.exit(main())
