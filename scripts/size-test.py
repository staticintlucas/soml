#!/usr/bin/env python3

import json
import subprocess
import tempfile
import toml
from pathlib import Path

here = Path(__file__).parent

soml_dir = here
while not (soml_dir.is_dir() and (soml_dir / "Cargo.toml").exists()):
  soml_dir = soml_dir.parent

manifest = toml.loads((soml_dir / "Cargo.toml").read_text())
assert manifest["package"]["name"] == "soml"

file = Path(__file__).relative_to(soml_dir)

crates = json.loads((here / "crates.json").read_text())

test_rs = """\
use serde::{Serialize, Deserialize};
use toml_crate::{from_str, to_string};

#[derive(Deserialize, Serialize)]
#[serde(untagged)]
enum Value {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec<Value>),
    Table(std::collections::HashMap<String, Value>),
}

fn main() {
    let input = std::fs::read_to_string("test1.toml").unwrap();
    let value: Value = from_str(&input).unwrap();
    let output = to_string(&value).unwrap();
    std::fs::write("test2.toml", output).unwrap();
}
"""

table = []

for crate in crates:
  with tempfile.TemporaryDirectory() as tmpdirname:
    tmpdir = Path(tmpdirname)

    cargo_crate = { k: v for k, v in crate.items() if k in ["package", "version", "path"] }
    if "path" in cargo_crate and not Path(cargo_crate["path"]).is_absolute():
      cargo_crate["path"] = str(soml_dir / cargo_crate["path"])


    cargo_toml = tmpdir / "Cargo.toml"
    cargo_toml.write_text(toml.dumps({
      "package": {
        "name": "size-test",
        "edition": "2024",
      },
      "dependencies": {
        "serde": { "version": "1.0", "features": ["derive"] },
        "toml_crate": cargo_crate,
      },
    }))

    src = tmpdir / "src"
    src.mkdir(parents=True, exist_ok=True)
    main_rs = src / "main.rs"
    main_rs.write_text(test_rs)

    bloat_cmd = ["cargo", "bloat", "--release", "--message-format=json"]
    bloat = subprocess.run(bloat_cmd, cwd=tmpdir, capture_output=True)
    if bloat.returncode != 0:
      print(bloat.stderr.decode())
      raise subprocess.CalledProcessError(bloat.returncode, bloat.args)
    size = json.loads(bloat.stdout)["text-section-size"]

    meta_cmd = ["cargo", "metadata", "--format-version=1"]
    meta = subprocess.run(meta_cmd, cwd=tmpdir, capture_output=True)
    if meta.returncode != 0:
      print(meta.stderr.decode())
      raise subprocess.CalledProcessError(meta.returncode, meta.args)
    [dep] = filter(lambda dep: dep["name"] == crate["package"], json.loads(meta.stdout)["packages"])

    row = {
      "name": crate["package"],
      "version": dep["version"],
      "size": f"{size / 1024:.0f} KiB",
      "maintained": "✅" if crate["maintained"] else "❌",
      "toml-ver": crate["toml-ver"].replace("\n", "<br>"),
      "url": crate["url"],
    }

    table.append(row)

print(f"""\
# Comparison of TOML crates

This table is autogenerated by [`{file}`]:

Crate | Version | Size &ast; | Maintained | TOML version
:----:|:-------:|:----------:|:----------:|:-----------:
{
  "\n".join(
    " | ".join([
      f"[{row["name"]}]",
      row["version"],
      row['size'],
      row["maintained"],
      row["toml-ver"],
    ])
    for row in table
  )
}

&ast; *Refers to the size of the `.text` section of a simple round-trip parse-then-write binary.
This is calculated using [`cargo-bloat`] with the release profile.* \\
† *Does not support TOML date-time types.*

{
  "\n".join(
    set(f"[{row["name"]}]: {row["url"]}" for row in table)
  )
}

[`{file}`]: {manifest["package"]["repository"]}/blob/v{manifest["package"]["version"]}/{file}
[`cargo-bloat`]: https://crates.io/crates/cargo-bloat""")
